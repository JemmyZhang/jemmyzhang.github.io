<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python基础知识点总结]]></title>
    <url>%2F2018%2F05%2F01%2Fpython-learning-starter%2F</url>
    <content type="text"><![CDATA[本文参考自廖雪峰的Python入门教程，对Python语法的知识点做了一些梳理，感谢廖老师的精彩博文。 Python中的变量和数据类型Python中的数据类型包括整数，浮点数，布尔值，字符串和空值五类。 整数整数的长度范围：2.732位：-2^31~2^31-1 64位：-2^63~2^63-13.5int长度理论无限 浮点数可以用科学计数法表示，例如1.23e9表示1.23*10^9 布尔值Python中的布尔类型布尔类型用True和False表示。注意首字母大写。Python把0，空字符串’’和None看成是False，其他数值和非空字符串看成是True。与运算：True and True或运算：True or False非运算：not True 布尔运算布尔运算遵循短路原则，能够提前确定计算结果，将不会继续往后计算。例如： 12a = Trueprint a and 'a=123' or '' 首先是表达式a and &#39;a=123&#39;，由于a为True，值取决于&#39;a=123&#39;，&#39;a=123&#39;在布尔运算中值被当做True，因此表达式的结果输出a=123。然后看&#39;a=123&#39; or &#39;&#39;，由于&#39;a=123&#39;为True，根据短路原则，表达式结果为&#39;a=123&#39;。因此整体表达式结果为a=123。 字符串字符串表示字符串用&#39;&#39;或者&quot;&quot;括起来，类比JavaScript。如果字符串里包含引号，需要进行转义。r&#39;...&#39;语法进行集中转义，如果字符串不包含&#39;&#39;或者&quot;&quot;可以集中用。 多行表示用&#39;&#39;&#39;...&#39;&#39;&#39;表示： 123'''Line 1Line 2Line 3''' 用r可以把多行字符串变成一个raw字符串。//raw字符串是什么？ 字符串编码ASCII码的大小是1个字节，1个字节内最大表示字符的数量为255，显然不足以包含所有字符。为了解决中文，日文，韩文等出现的问题，出现了Unicode，把所有语言统一编到一套编码里，就不会有编码问题了。 但是Python诞生比Unicode还要早，因此最早的Python只能支持ASCII码，例如&#39;ABC&#39;就是以ASCII码编码的。 后来添加了对Unicode的支持，表示形式u&#39;...&#39;；多行显示u&#39;&#39;&#39;...&#39;&#39;&#39;；raw+多行显示ur&#39;&#39;&#39;...&#39;&#39;&#39; 如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释 1# -*- coding: utf-8 -*- 目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为… 并选择UTF-8格式保存。 空值空值是Python里面特殊的值，用None表示。 变量变量的命名规则：变量名为大小写英文，数字和下划线，且不能用数字开头。 列表Python内置数据类型list，语法上用[...]来囊括元素。由于Python是动态语言，所以列表里面可以（混合）容纳各种类型的数据。 列表除了常规的下标索引以外，还可以使用倒序或者切片等手段进行访问。 倒序访问例如访问倒数第N个元素(注意数组不要越界)： 1print L[-N] 添加新元素方法一：使用list的append()方法，例如： 1234list = ['Adam', 'Lisa', 'Bart']list.append（'Tony'）print list# output: ['Adam', 'Lisa', 'Bart','Tony'] 方法二：使用list的insert()方法。list接收两个参数，第一个参数是索引，第二个参数是元素。例如在索引位置0加入一个元素： 1234&gt;&gt;&gt; list=['Adam','Lisa']&gt;&gt;&gt; list.insert(0,'Tony')&gt;&gt;&gt; list# output: ['Tony', 'Adam', 'Lisa'] Q：如果insert的索引位超过列表的最大索引？例如list.insert(10,&#39;Tony&#39;)。A：此时元素将默认添加到列表末尾。 删除元素使用pop()方法删除列表尾部元素，利用pop(N)删除索引为N的元素。 替换元素基于下标索引直接替换，例如list[2]=&#39;Peter&#39; 有序列表Tupletuple是一种有序列表，一旦创建完成就无法修改。 1&gt;&gt;&gt; t = ('Adam', 'Lisa', 'Bart') tuple可以使用索引或者倒序索引访问，但是无法修改或者删除元素了。 单元素Tuple如果没有元素，可以使用t=()语法。如果只有一个元素，需要使用t=(1,)语法。这是由于如果只是使用t=(1)这种语法，解释器会认为这是一个括号运算符。 “可变”TupleTuple中的元素还是区分值类型和引用类型的，例如一个Tuple中包含一个list数组，Tuple的元素位就会指向list的引用。list的内容是可变的。例如： 12345&gt;&gt;&gt; t = ('a', 'b', ['A', 'B'])&gt;&gt;&gt; L = t[2]&gt;&gt;&gt; L.append('C')&gt;&gt;&gt; print t# output: ('a', 'b', ['A', 'B', 'C']) 如果要想Tuple不可变，那么应该保证Tuple中的所有元素不变。例如上例中的list应该替换成Tuple类型。 1&gt;&gt;&gt; t = ('a', 'b', ('A', 'B')) 判断和其他语言不通，关键字if之后不加括号，并且判断条件后跟冒号：后换行。函数范围依靠缩进来保证，不需要括号。例如： 12345age = 20if age &gt;= 18: print 'your age is', age print 'adult'print 'END' Python是严格缩进的语言，请使用4个空格的缩进，而不是Tab。 if..else示例： 1234if age &gt;= 18: print 'adult'else: print 'teenager' if..elif..else对应if..else if..else的逻辑，下面示例： 1234567age = 8if age &gt;= 6 and age &lt;18: print 'teenager'elif age &gt;= 18: print 'adult'else: print 'kid' 循环for循环for循环采用for .. in ...这种语法，这里的..代表迭代的元素，...代表集合。 12for value in [1,2,3,4]: print value Q：如何一边迭代一边拿到迭代元素下标？A：可以采用python标准函数库内建的enumerate函数。enumerate的语法是enumerate(sequence,start=0)，其中sequence是可迭代对象，可以使列表，字典，文件对象等。start是计数枚举的起始值。例如： 1234567891011list=["Ted","Infi","Sky","Fly","Moon"]enum_obj=enumerate(list,0)for key,value in enum_obj: print key,value# output below0 Ted1 Infi2 Sky3 Fly4 Moon while循环语法 while ...,...是判断条件，例如： 12345N = 10x = 0while x &lt; N: print x x = x + 1 break和continue使用break可以中断循环，利用continue可以跳过此轮进入后续循环，这个和其他语言大同小异。 字典Dict字典表现形式就是键值对集合。类似于Java中的Map，语法格式：d={&#39;Adam&#39;:98,&#39;Tony&#39;:100,&#39;Bart&#39;:95} 可以用len函数计算dict的长度。例如len(d)。 所有的集合都可以用len来计算长度，包括list，tuple，dict。 Dict的访问可以用key查找对应的value，与list很像。不同的是，list用的是下标索引，而dict用的是key。例如： 12&gt;&gt;&gt; print d['Adam']# output: 95 如果key存在，dict会返回具体的value，如果key不存在，会报KeyError。 dict查找速度很快（底层应该是Hash结构，有待了解）。 dict存储没有顺序，存储过程中key不可变，不能重复。例如list是可变的，因此不能作为key。 Dict更新更新可以基于key-value直接赋值。如果key已经存在，新的value会替换原有的value。 1d['Paul'] = 72 Dict迭代Dict可以用for循环对key进行迭代，例如： 1234567&gt;&gt;&gt; dict = &#123; 'Tony': 100, 'Steve': 85, 'Bill': 59 &#125;&gt;&gt;&gt; for key in dict:... print key... LisaAdamBart 迭代Dict的value可以将dict转化成一个包含所有的list，这样就可以对dict的每一个value进行迭代： 123dict = &#123; 'Tony': 100, 'Steve': 85, 'Bill': 59 &#125;for value in dict.values(): print value Setdict是建立一组key和value的映射关系，dict的key不能重复。而set持有一系列元素，但是set里面元素没有重复，而且是无序的。set和dict的key很像。 set添加语法采用set()函数，例如s = set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])。如果传入的元素中包含重复的元素，set会自动去重。set包含add方法，可以通过s.add(1)语法来添加元素。如果是重复的元素就会自动去重。 set删除可以通过s.remove()函数删除元素。删除前需要判断元素是否存在，如果元素不存在还进行喊出，remove方法会报错。 Set元素访问由于Set是无序集合，所以不能通过索引来访问。我们可以用in来判断元素是否存在： 1234s = set(['a', 'b', 'c', 'd'])&gt;&gt;&gt; 'a' in s# output: True Set遍历语法参考list等集合 Set特点总结Set内部结构和dict很像，区别是不存储value。Set存储元素和dict的key，类似，必须是不变对象。set元素也是没有顺序的。 函数定义函数定义函数使用def关键字，然后跟：，在缩进块中编写函数体。遇到return语句返回。 12345def my_abs(x): if x &gt;= 0: return x else: return -x 返回值Python一个特点是语法上支持多返回值。在写法上支持多返回值，其实本质上返回值却是返回一个tuple，例如： 123456789def move(x,y): return x+100,y+200x,y=move(100,200)print x,y# ouput 200,400r=move(100,200)print r# ouput (200,400) 递归函数递归就是自己调自己，和其他语言一样，这里不再赘述，注意递归函数要添加退出条件。 默认参数定义函数的时候，可以包含默认参数。语法例子如下： 12def power(x, n=1): return x+n 这样在传值的时候，可以只传一个参数： 12power(2):# output: 3 默认参数只能定义在必须参数后面 Python可变参数如果想让函数能够接受任意参数，就可以定义可变参数。语法如下： 12def function(*args): ... 可变参数的本质还是一个tuple，args可以直接当做一个tuple来用。 切片Python提供了切片操作大大简化了集合和字符串等的操作。切片的语法是list[x:y:z]函数。x，y，z指的是‘开始元素’：‘最后元素’：‘取元素间隔. 集合切片操作例如对list进行截取，可以采用list[0:3]这种语法。这表示从索引0开始取，直到索引3为止，但是不包括索引3。如果开始的索引是0，则0可以省略,语法为list[:3]。如果只用一个：，表示切片的范围是从头到尾。list[:]的含义就是完整复制出一个新的list。切片还能够指定第三个操作，第三个元素表示了取元素的间隔。例如list[1:10:2]这个代表从索引1开始取，每2个元素取1个，到索引10为止。 倒序切片倒序切片和正序切片类似，只要按照切片语法的去理解，就很容易。例如：L[-4:-1:2]代表起始元素是索引倒数第四个元素，最后元素索引倒数第一个元素，取元素间隔是2。 字符串切片字符串也是可以进行切片操作的，结果仍然是字符串。这种截取字符串的操作很简单。 12&gt;&gt;&gt; 'ABCDEFG'[::2]# output: 'ACEG' 迭代在Python中，通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。有序集合，无需集合，键值对dict俊可以进行迭代。迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。 索引迭代对于有序集合，元素是有索引的，如果想到到索引，就需要使用enumerate()函数。enumerate函数会将集合包装成一个tuple的集合。例如： 1['Adam', 'Lisa', 'Bart', 'Paul'] 变成了类似： 1[(0, 'Adam'), (1, 'Lisa'), (2, 'Bart'), (3, 'Paul')] 迭代dict的value（两种方式对比）前文已经提到了一种方式，即我们可以将dict转化成一个包含所有的list，这样我们就可以对dict的每一个value进行迭代： 123dict = &#123; 'Tony': 100, 'Steve': 85, 'Bill': 59 &#125;for value in dict.values(): print value 第二种方式是使用dict的itervalues方法。 123dict = &#123; 'Tony': 100, 'Steve': 85, 'Bill': 59 &#125;for value in dict.itervalues(): print value 两个方法的区别： values()方法实际上把dict转化成了包含value的list。 itervalues()方法不会转换，一次从dict去除了value，因此比values()方法更节省内存。 迭代dict的key和value可以对dictitems()的返回值进行迭代，从而同时得到dict的key和value。dict的items方法返回了包含key和value的tuple组合的列表。例如： 123dict=&#123;'Tom':95,'Jim':90,'Bill':85&#125;print dict.items()# output: [('Jim', 90), ('Bill', 85), ('Tom', 95)] 因此我们可以对items()的返回值进行迭代，同时获得key和value： 1234dict=&#123;'Tom':95,'Jim':90,'Bill':85&#125;print dict.items()for key,value in dict.items(): print key,"-",value 和itervalues()类似，items()也有一个对应的iteritems()，也是不需要转化成list，所以iteritems()不需要占用额外内存。 列表生成式生成列表我们可以借助range函数。例如： 12range(1, 10)# output: [1, 2, 3, 4, 5, 6, 7, 8, 9] 如果要生成比较复杂的类型，使用range生成的语法就比较冗长，例如生成10以内平方数的列表集合： 123l=[]for x in range(1, 10): l.append(x * x) 这时候我们可以借助列表生成式来实现上面的list： 1[x * x for x in range(1, 10)] 在这个表达式中，要生成的元素x * x放在表达式前面，后面跟for语句，我们就可以把list生成出来。 条件过滤如果我们在列表生成式中想加入条件过滤，可以在for循环后面加入if判断，例如： 12[x * x for x in range(1, 10) if x % 2 ==0]# output: [4, 16, 36, 64] 意为筛选出1到9区间内所有偶数的平方数 列表。 多层表达式for循环可以嵌套，所以在列标生成式中也可以多层for循环来生成列表。 12[x + y for x in 'hello' for y in '123']# output: ['h1', 'h2', 'h3', 'e1', 'e2', 'e3', 'l1', 'l2', 'l3', 'l1', 'l2', 'l3', 'o1', 'o2', 'o3'] 参考文献 https://www.imooc.com/learn/177]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot单元测试指南]]></title>
    <url>%2F2018%2F04%2F29%2Fspring-boot-unittest%2F</url>
    <content type="text"><![CDATA[单元测试是编写测试代码，用来检测特定的、明确的、细颗粒的功能。Spring Boot提供了多种工具包和注解来帮助用户对应用进行单元测试。Spring Boot测试支持由下面两个模块提供：spring-boot-test包含了核心组件，而spring-boot-test-autoconfigure则能够提供自动化的配置。一般情况下，开发者可以在POM文件中通过添加spring-boot-starter-test来支持单元测试。 基础概念单元测试并不一定保证程序功能是正确的，更不保证整体业务是准备的。单元测试不仅仅用来保证当前代码的正确性，更重要的是用来保证代码修复、改进或重构之后的正确性。一般来说，单元测试任务包括： 接口功能测试：用来保证接口功能的正确性。 局部数据结构测试（不常用）：用来保证接口中的数据结构是正确的 比如变量有无初始值 变量是否溢出 边界条件测试 变量没有赋值（即为NULL） 变量是数值（或字符) 主要边界：最小值，最大值，无穷大（对于DOUBLE等） 溢出边界（期望异常或拒绝服务）：最小值-1，最大值+1 临近边界：最小值+1，最大值-1 变量是字符串 引用“字符变量”的边界 空字符串 对字符串长度应用“数值变量”的边界 变量是集合 空集合 对集合的大小应用“数值变量”的边界 调整次序：升序、降序 变量有规律 比如对于Math.sqrt，给出n^2-1，和n^2+1的边界 所有独立执行通路测试：保证每一条代码，每个分支都经过测试 代码覆盖率 语句覆盖：保证每一个语句都执行到了 判定覆盖（分支覆盖）：保证每一个分支都执行到 条件覆盖：保证每一个条件都覆盖到true和false（即if、while中的条件语句） 路径覆盖：保证每一个路径都覆盖到 相关软件 Cobertura：语句覆盖 Emma: Eclipse插件Eclemma 各条错误处理通路测试：保证每一个异常都经过测试 测试Spring Boot的应用Spring Boot应用包含了Spring的应用上下文。如果您在测试的时候需要使用到Spring Boot的特性或者Spring的应用上下文，Spring Boot提供了一种@SpringBootTest注解，可以帮助您运行并测试Spring应用。 您还可以通过@SpringBootTest注解的webEnvironment属性来改变运行的属性。 MOCK：该模式应用会装载WebApplicationContext并提供一个虚拟的Servlet环境。内置的Servlet容器不会被启动。如果Classpath中没有Servlet API，该模式会启动一个非WEB的普通ApplicationContext。 RANDOM_PORT：应用装载了ServletWebServerApplicationContext提供了一个真实的Servlet容器环境，不过该容器监听的端口是随机的。 DEFINED_PORT：和RANDOM_PORT模式类似，区别在于端口号是固定的，该端口号会从application.properties中读取，或者默认8080。 NONE：仅仅装载了ApplicationContext，不会提供任何Servlet环境（例如mock或者其他） 注意： 除了@SpringBootTest还有很多其他的注解，为单元测试提供更多个性化的测试。 不要忘记添加@RunWith(SpringRunner.class)注解，不然其他注解将会被忽略。 下例是测试一个可运行的Server应用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package pers.jz.unittest.test;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.mockito.BDDMockito;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.mock.mockito.MockBean;import org.springframework.boot.test.mock.mockito.SpyBean;import org.springframework.boot.test.web.client.TestRestTemplate;import org.springframework.test.context.junit4.SpringRunner;import pers.jz.unittest.entity.User;import pers.jz.unittest.service.MathService;import pers.jz.unittest.service.UserService;import javax.annotation.Resource;/** * @author jemmyzhang on 2018/4/3. */@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)@RunWith(SpringRunner.class)public class MyUnitTest &#123; @Resource private TestRestTemplate testRestTemplate; @SpyBean private MathService spyMathService; @MockBean private UserService mockUserService; @Test public void exampleTest() &#123; String body = testRestTemplate.getForObject("/math/", String.class); Assert.assertEquals("PI: 3.141592653589793", body); &#125; @Test public void spyMathTest() &#123; Object result = spyMathService.add(1, 2); Assert.assertEquals(3, result); &#125; @Test public void mockUserTest() &#123; BDDMockito.given(mockUserService.findDefaultUser()).willReturn(new User(-1L, "ADMIN", "ADMIN_EMAIL", "ADMIN_ADDR")); Object result = mockUserService.findDefaultUser(); Assert.assertEquals(new User(-1L, "ADMIN", "ADMIN_EMAIL", "ADMIN_ADDR"), result); &#125;&#125; 在上面这个例子中(1)和(2)分别添加了@RunWith(SpringRunner.class)注解和@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)注解，这样就能启动Spring上下文。@Resource能够将Spring容器中的实例注入到代码中；在方法上加入@Test注解使方法成为一个测试用例。在用例中，我们可以使用Assert断言来判断函数的执行结果是否符合我们的逻辑预期。 Mock Bean和Spy Bean上文的例子中包含了@MockBean注解和@SpyBean注解（注释中）。所谓的Mock测试，指的是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。Mock测试同时可以对某些现实环境中难以触发的失败情形进行测试。 @MockBean注解能够定义一个bean为虚拟形式，该注解能够直接作用于类对属性或者配置类。Mock bean会在每一个@Test测试方法执行以后被自动重置。在上面的例子中，我们虚拟了一个UserService的一个方法，使之能够返回一个虚拟的User对象，并为User对象赋予特定的属性值。这样在服务被调用时，返回的对象就是我们预先定义好的返回值。 12BDDMockito.given(mockUserService.findDefaultUser()).willReturn(new User(-1L, "ADMIN", "ADMIN_EMAIL", "ADMIN_ADDR"));Object result = mockUserService.findDefaultUser(); 对于@SpyBean，和@MockBean的区别就在于如果你mock了一个类，那么这个类的所有的函数都被Mockito改写了（如果是没有返回值的函数，则什么都不做，如果是有返回值，会返回默认值，比如布尔型的话返回false，List的话会返回一个空的列表，int的话会返回0等等），如果你Spy了一个类，那么所有的函数都没有被改变，除了那些被你打过桩的函数。 自动化配置的测试Spring Boot的自动配置系统对Spring Boot应用是一种非常好的体验，但是对于单元测试而言，似乎有点过犹不及。在单元测试场景，我们经常会遇到如下场景：我们在某一个时刻只需要测试系统的部分功能，但不想牵涉到其他的模块。例如我们希望测试Spring MVC的控制器映射的URL是否正确，而并不想实际调用到数据库。或者你指向测试JPA实体，而并不想触及Web层。Spring Boot引入了一个测试切片（slice）的概念，能够帮助我们限制我们想要测试的组件。注解的命名形式是@…​Test，例如@JsonTest，@WebMvcTest等。每一个切片测试只会引入很有限的自动配置类，您可以使用注解上的excludeAutoConfiguration属性来排除部分自动配置类。如果您对切片测试不感兴趣，但是又只想使用部分自动配置类，您可以使用@AutoConfigure…​注解和标准的@SpringBootTest的组合配置。 所有自动化配置的加载类可以在https://docs.spring.io/spring-boot/docs/current/reference/html/test-auto-configuration.html里找到。 自动化配置的JSON测试想要测试JSON序列化和反序列化工作是否正常，您可以使用@JsonTest注解，@JsonTest自动化配置支持以下工具类来支持JSON映射器： Jackson ObjectMapper Gson Jsonb Spring Boot还提供了基于AssertJ的JSONassert和JsonPath灯类库来辅助测试。JacksonTester，GsonTester，JsonbTester和BasicJsonTester可以分别被应用在Jackson, Gson, Jsonb和字符串。当使用了@JsonTest注解，所有这些类库能够使用@Autowired进行依赖注入。下面是JsonTest的一个例子： 12345678910111213141516171819202122232425262728293031323334353637383940package pers.jz.unittest.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.autoconfigure.json.JsonTest;import org.springframework.boot.test.json.JacksonTester;import org.springframework.test.context.junit4.SpringRunner;import pers.jz.unittest.entity.User;import javax.annotation.Resource;import static org.assertj.core.api.Assertions.assertThat;/** * @author jemmyzhang on 2018/4/3. */@RunWith(SpringRunner.class)@JsonTestpublic class MyJsonTest &#123; @Resource private JacksonTester&lt;User&gt; json; @Test public void testSerialize() throws Exception &#123; User user = User.withId(1L).name("admin").email("admin@hotmail.com").address("Hangzhou").build(); assertThat(json.write(user)).isEqualToJson("expected.json"); assertThat(this.json.write(user)).hasJsonPathStringValue("@.name"); assertThat(this.json.write(user)).extractingJsonPathStringValue("@.name").isEqualToIgnoringCase("admin"); &#125; @Test public void testDeSerialize() throws Exception &#123; String content = "&#123;\"id\":1,\"name\":\"admin\",\"email\":\"admin@hotmail.com\",\"address\":\"Hangzhou\"&#125;"; User user = new User(1L, "admin", "admin@hotmail.com", "Hangzhou"); assertThat(json.parse(content)).isEqualTo(user); assertThat(json.parseObject(content).getName()).isEqualTo("admin"); &#125;&#125; 自动化配置的Spring MVC测试@WebMvcTest可以用来测试Spring MVC的控制器是否工作正常。自动化配置会加载@Controller，@ControllerAdvice，@JsonComponent，Converter，GenericConverter，Filter，WebMvcConfigurer，HandlerMethodArgumentResolver等组件，但是上下文中基于@Component注解的bean将不会被扫描到。 如果需要加载其他额外的组件，例如刚才说到的基于@Component注解的组件，可以使用@Import类注解来帮助我们加载需要加载的类。 一般而言，一个@WebMvcTest之对应于单一个Controller，并且利用@MockBean进行请求合并。@WebMvcTest自动加载了MockMvc，因此我们能够快速测试MVC控制器而不需要启动一个完整的HTTP服务器。下面是一个基于@WebMvcTest的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142package pers.jz.unittest.test;import com.google.gson.Gson;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;import org.springframework.boot.test.mock.mockito.MockBean;import org.springframework.http.MediaType;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import pers.jz.unittest.controller.UserController;import pers.jz.unittest.entity.User;import pers.jz.unittest.service.UserService;import javax.annotation.Resource;import static org.mockito.BDDMockito.given;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;/** * @author jemmyzhang on 2018/4/3. */@RunWith(SpringRunner.class)@WebMvcTest(UserController.class)public class MyControllerTest &#123; @Resource private MockMvc mvc; @MockBean private UserService userService; @Test public void testTemplate() throws Exception &#123; given(userService.findDefaultUser()).willReturn(new User(1L, "admin", "admin@163.com", "Internet business road 499")); User defaultUser = userService.findDefaultUser(); mvc.perform(get("/users/default").accept(MediaType.APPLICATION_JSON)).andExpect(status().isOk()).andExpect(content().json(new Gson().toJson(defaultUser))); &#125;&#125; 自动化配置的REST客户端测试@RestClientTest注解可以用于测试REST客户端，默认情况下，该注解能够自动配置Jackson，GSON和Jsonb。如果想要测试特定的类，则需要使用到@RestClientTest类的value或components注解。以下是一个REST调用的例子：首先定义了一个Service类： 1234567891011121314151617181920package pers.jz.unittest.service;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;/** * @author jemmyzhang on 2018/4/3. */@Servicepublic class RestService &#123; @Resource RestTemplate restTemplate; public String invokeRoot() &#123; return restTemplate.getForObject("http://localhost:8080/", String.class); &#125;&#125; 并在WebConfig文件里实例化了一个RestTemplate: 1234567891011121314151617package pers.jz.unittest.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;/** * @author jemmyzhang on 2018/4/3. */@Configurationpublic class WebConfig &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; REST测试类如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package pers.jz.unittest.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.autoconfigure.web.client.RestClientTest;import org.springframework.boot.test.web.client.MockServerRestTemplateCustomizer;import org.springframework.context.annotation.Import;import org.springframework.http.MediaType;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.client.MockRestServiceServer;import org.springframework.web.client.RestTemplate;import pers.jz.unittest.config.WebConfig;import pers.jz.unittest.service.RestService;import javax.annotation.Resource;import static org.assertj.core.api.Assertions.assertThat;import static org.springframework.test.web.client.match.MockRestRequestMatchers.requestTo;import static org.springframework.test.web.client.response.MockRestResponseCreators.withSuccess;/** * @author jemmyzhang on 2018/4/3. */@RunWith(SpringRunner.class)@RestClientTest(RestService.class)@Import(WebConfig.class)//...(1)public class ExampleRestClientTest &#123; @Resource private RestTemplate restTemplate; @Resource(name = "restService") private RestService restService; @Resource MockServerRestTemplateCustomizer mockServerRestTemplateCustomizer; @Resource private MockRestServiceServer mockRestServiceServer; @Test public void testRestResult() throws Exception &#123; mockServerRestTemplateCustomizer.customize(restTemplate);//...(2) mockRestServiceServer.expect(requestTo("http://localhost:8080/")).andRespond(withSuccess("tomcat8", MediaType.TEXT_PLAIN)); String call = restService.invokeRoot(); assertThat(call).isEqualTo("tomcat8"); &#125;&#125; 由于RestService依赖RestTemplate，而@RestClientTest不会自动加载带有@Component注解的组件，因此需要使用（1）中的@Import注入，并且在（2）中配置到MockServerRestTemplateCustomizer中。mockRestServiceServer能够虚拟请求的一个返回结果，而不会真正调用REST接口。 参考文献 https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.htmlhttps://blog.csdn.net/dc_726/article/details/8713236https://www.cnblogs.com/AloneSword/p/4109407.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Cloud</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
